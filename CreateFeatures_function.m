function [Features, Labels] = CreateFeatures_function( filename, TimeWindows );

%% Import data from text file.
% Script for importing data from the following text file:
%
%    /Users/alittle2/Dropbox/JU/Scholarship/MachineLearning_Security/RealTime/CodeForDARPA/inside_5_5_new.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2017/05/03 14:11:25

%% Initialize variables.
%filename = 'inside_5_1_split_11.csv';
delimiter = ',';
startRow = 2;

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%q%q%q%q%q%q%q%q%q%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'HeaderLines' ,startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
  raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
  for col=1:length(dataArray)-1
      raw(1:length(dataArray{col}),col) = dataArray{col};
  end
  numericData = NaN(size(dataArray{1},1),size(dataArray,2)); 

%  col = 8;
%      % Converts strings in the input cell array to numbers. Replaced non-numeric
%      % strings with NaN.
%      rawData = dataArray{col};
%      for row=1:size(rawData, 1)
%          % Create a regular expression to detect and remove non-numeric prefixes and
%          % suffixes.
%          regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
%          try
%              result = regexp(rawData{row}, regexstr, 'names');
%              numbers = result.numbers;
%              
%              % Detected commas in non-thousand locations.
%              invalidThousandsSeparator = false;
%              if any(numbers==',')
%                  thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
%                  if isempty(regexp(numbers, thousandsRegExp, 'once'))
%                      numbers = NaN;
%                      invalidThousandsSeparator = true;
%                  end
%              end
%              % Convert numeric strings to numbers.
%              if ~invalidThousandsSeparator
%                  numbers = textscan(strrep(numbers, ',', ''), '%f');
%                  numericData(row, col) = numbers{1};
%                  raw{row, col} = numbers{1};
%              end
%          catch me
%          end
%      end
 
%no = cellfun(@str2num,dataArray{1, 3});
%length = cellfun(@str2num,dataArray{1, 8});

% Convert the contents of columns with dates to MATLAB datetimes using date
% format string.
try
    dates{4} = datetime(dataArray{4}, 'Format', 'HH:mm:ss.SS', 'InputFormat', 'HH:mm:ss.SS');
catch
    try
        % Handle dates surrounded by quotes
        dataArray{4} = cellfun(@(x) x(2:end-1), dataArray{4}, 'UniformOutput', false);
        dates{4} = datetime(dataArray{4}, 'Format', 'HH:mm:ss.SS', 'InputFormat', 'HH:mm:ss.SS');
    catch
        dates{4} = repmat(datetime([NaN NaN NaN]), size(dataArray{4}));
    end
end

anyBlankDates = cellfun(@isempty, dataArray{4});
anyInvalidDates = isnan(dates{4}.Hour) - anyBlankDates;
dates = dates(:,4);
% 
%  %% Split data into numeric and cell columns.
%  % rawNumericColumns = raw(:, 8);
rawCellColumns = raw(:, [1,2,5,6,7,9]);
%  
%  
%% Replace non-numeric cells with NaN
% R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),rawNumericColumns); % Find non-numeric cells
% rawNumericColumns(R) = {NaN}; % Replace non-numeric cells

% Create output variable
X = table;
X.LLClass = rawCellColumns(:, 1);
X.HLClass = rawCellColumns(:, 2);
% %X.No = no;
X.Time = dates{:, 1};
X.Source = rawCellColumns(:, 3);
X.Destination = rawCellColumns(:, 4);
X.Protocol = rawCellColumns(:, 5);
X.Length = cellfun(@str2num,dataArray{1, 8});
X.Info = rawCellColumns(:, 6);

%% Clear temporary variables
clearvars filename delimiter startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers inval

%% Define additional packet-level features which will be used to compute features for various time windows
X.Time = 3600*hour(X.Time)+60*minute(X.Time)+second(X.Time); % Convert datetime format to time in seconds (only use for csv files!)

%% Packet Interarrival
X.PacketInterarrival = [0; diff(X.Time)]; % Time since previous packet; for first packet make this zero since there is no prior packet

% Create a new time column that is always increasing by adding 3,600 when
% the hour changes
% Note: negative(1:8) is required to include 8 different hours that may be
% included in one file
for i=1:8
    negative(i) = 0;
end
j = 1;
for i = 1:(length(X.Time) - 1)
    if(X.Time(i+1) - X.Time(i) < 0)
        negative(j) = i;
        j = j + 1;
    end
end
for j=1:8
    if negative(j) > 0
        for i = negative(j):length(X.Time)
            X.Time(i) = X.Time(i) + j*3600;
        end
    end
end

% Find indices which partition the data into one second intervals
edges = X.Time(1):1:X.Time(length(X.Time));
edges(length(edges)) = X.Time(length(X.Time)); %Round last entry up to include all times
SecondIndex = discretize(X.Time, edges);

% moved NumberOfSeconds for files that change the hour and we add 3,600 it
% needs to be calculated here
NumberOfSeconds = floor(X.Time(length(X.Time))-X.Time(1));
%% Compress Data into Second-level summary data (the summary data will be used to compute features over different time windows)
% Note: each row represents one second

XCompress = table;
XCompress.NumberOfPackets = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSum = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSumSquares = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSumCubes = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSum = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSumSquares = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSumCubes = zeros(NumberOfSeconds,1);
XCompress.HLClass = cell(NumberOfSeconds,1);
XCompress.LLClass = cell(NumberOfSeconds,1);
XCompress.CorJavaScriptCount = zeros(NumberOfSeconds,1);
XCompress.HTTPandMalformedCount = zeros(NumberOfSeconds,1);
XCompress.FTPandCcodeCount = zeros(NumberOfSeconds,1);
XCompress.SYNCount = zeros(NumberOfSeconds,1);
XCompress.ECHOCount = zeros(NumberOfSeconds,1);

for i=1:NumberOfSeconds
    index = find(SecondIndex==i);
    
    % Record the High level class
    % Note: if there are no packets in the interval, the label is taken
    % from the previous interval
    if length(index) == 0
        XCompress.HLClass(i) = XCompress.HLClass(i-1);
        XCompress.LLClass(i) = XCompress.LLClass(i-1);
    else
        possible_labelsHL = unique(X.HLClass(index));
        possible_labelsLL = unique(X.LLClass(index));
        if length(possible_labelsHL) == 1
           XCompress.HLClass(i) = possible_labelsHL;
           XCompress.LLClass(i) = possible_labelsLL;
        else
            n = zeros(length(possible_labelsHL), 1);
            for j = 1:length(possible_labelsHL)
              n(j) = length(find(strcmp(possible_labelsHL{j}, X.HLClass(index))));
            end
            [~, itemp] = max(n);
            XCompress.HLClass(i)=possible_labelsHL(itemp);
            XCompress.LLClass(i)=possible_labelsLL(itemp);
        end
    end

    % Packet Size Info (for CV and third moment of packet size)
    XCompress.NumberOfPackets(i) = length(index);
    XCompress.PacketSizeSum(i) = sum(X.Length(index));
    XCompress.PacketSizeSumSquares(i) = sum(X.Length(index).^2);
    XCompress.PacketSizeSumCubes(i) = sum(X.Length(index).^3);
    
    % Inter-arrival info (for CV of packet inter-arrival rate)
    XCompress.InterarrivalSum(i) = sum(X.PacketInterarrival(index));
    XCompress.InterarrivalSumSquares(i) = sum(X.PacketInterarrival(index).^2);
    XCompress.InterarrivalSumCubes(i) = sum(X.PacketInterarrival(index).^3);
    
    % Record C or Javascript Count 
    %may not use this
    if length(index)>0
        expr_C = '} | { |if( | for( | main(';
        expr_Javascript = 'attr|index|all|id|value|className|document|getElement*';
        code_flag_count = 0;
        for j=index(1):index(length(index));
            [startStr1] = regexp(X.Info(j), expr_C);
            [startStr2] = regexp(X.Info(j), expr_Javascript);
            if(length(startStr1{1,1}) > 0 || length(startStr2{1,1}) > 0)
                code_flag_count = code_flag_count+1;
            end
        end
        XCompress.CorJavaScriptCount(i) = code_flag_count;
    end
    
    % Record HTTP and Malformed Count
    if length(index)>0
        code_flag_count = 0;
        for j=index(1):index(length(index));
            [startStr6] = regexp(X.Protocol(j), 'HTTP');
            [startStr7] = regexp(X.Info(j), 'Malformed Packet');
            if(length(startStr6{1,1}) > 0 && length(startStr7{1,1}) > 0)
                code_flag_count = code_flag_count+1;
            end
        end
        XCompress.HTTPandMalformedCount(i) = code_flag_count;
    end
    
    % Record FTP in protocol and "*.c" in content flag
    if length(index)>0
        code_flag_count = 0;
        for j=index(1):index(length(index));
            [startStr6] = regexp(X.Protocol(j), 'FTP');
            [startStr7] = regexp(X.Info(j), '.c');
            if(length(startStr6{1,1}) > 0 && length(startStr7{1,1}) > 0)
                code_flag_count = code_flag_count+1;
            end
        end
        XCompress.FTPandCcodeCount(i) = code_flag_count;
    end
    
    % Record Protocol Counts
    if length(index)>0
       syn_string = 'SYN';
       disp(strcmp(syn_string,regexp(X.Info(index),syn_string,'match')));%matches the regexp to see if it returns a SYN
        %disp('yoyoyo the X.Info(index) is ');disp(X.Info(index));
       XCompress.SYNCount(i) = length(strcmp(syn_string,regexp(X.Info(index),syn_string,'match')));
      % XCompress.SYNCount(i) = length(find(strcmp('SYN', X.Info(index)))); %possibly change to X.Info and use REGEX. Was X.Protocol
       XCompress.ECHOCount(i) = length(find(strcmp('ECHO', X.Info(index)))); 
    end
    
end

%% Define Features In Various Time Windows

T = length(TimeWindows);
% First time that we can compute features for ALL windows
tstart = max(TimeWindows);
tend = length(XCompress.NumberOfPackets);
ttotal = tend - tstart;

Features = struct;
Labels = struct;

Features.CVPacketSize = zeros(ttotal,T);
Features.ThirdMomentPacketSize = zeros(ttotal,T);
Features.CVPacketInterarrival = zeros(ttotal,T);
Features.ThirdMomentPacketInterarrival = zeros(ttotal,T);
Features.CorJavaScriptCount = zeros(ttotal,T);
Features.HTTPandMalformedCount = zeros(ttotal,T);
Features.FTPandCcodeCount = zeros(ttotal,T);
Features.SYNCount = zeros(ttotal,T);
Features.ECHOCount = zeros(ttotal,T);

Labels.HLClass = cell(ttotal,1);
Labels.LLClass = cell(ttotal,1);

for t=tstart:tend %Loop over times
    for i = 1:T %Loop over windows
        Labels.HLClass(t-tstart+1) = XCompress.HLClass(t);
        Labels.LLClass(t-tstart+1) = XCompress.LLClass(t);
        Features.SYNCount(t-tstart+1, i) = sum(XCompress.SYNCount(t-TimeWindows(i)+1 : t));
        Features.CorJavaScriptCount(t-tstart+1, i) = sum(XCompress.CorJavaScriptCount(t-TimeWindows(i)+1 : t));
        Features.HTTPandMalformedCount(t-tstart+1, i) = sum(XCompress.HTTPandMalformedCount(t-TimeWindows(i)+1 : t));
        Features.FTPandCcodeCount(t-tstart+1, i) = sum(XCompress.FTPandCcodeCount(t-TimeWindows(i)+1 : t));
        Features.SYNCount(t-tstart+1, i) = sum(XCompress.SYNCount(t-TimeWindows(i)+1 : t));
        Features.ECHOCount(t-tstart+1, i) = sum(XCompress.ECHOCount(t-TimeWindows(i)+1 : t));
        % Construct features from sotred information: 
        number_packets = sum(XCompress.NumberOfPackets(t-TimeWindows(i)+1 : t));
        if number_packets > 0
            % Packet Size
            sum_packetsize = sum(XCompress.PacketSizeSum(t-TimeWindows(i)+1 : t));
            sumsquares_packetsize = sum(XCompress.PacketSizeSumSquares(t-TimeWindows(i)+1 : t));
            sumscubes_packetsize = sum(XCompress.PacketSizeSumCubes(t-TimeWindows(i)+1 : t));
            mean_packetsize = sum_packetsize / number_packets;
            var_packetsize = (sumsquares_packetsize / number_packets) - mean_packetsize^2;
            Features.CVPacketSize(t-tstart+1, i) = sqrt(var_packetsize)/mean_packetsize;
            Features.ThirdMomentPacketSize(t-tstart+1, i) = (sumscubes_packetsize/number_packets) - 3*mean_packetsize*(sumsquares_packetsize/number_packets) + 2*mean_packetsize^3;
            % Packet Interarrival
            sum_interarrival = sum(XCompress.InterarrivalSum(t-TimeWindows(i)+1 : t));
            sumsquares_interarrival = sum(XCompress.InterarrivalSumSquares(t-TimeWindows(i)+1 : t));
            sumscubes_interarrival = sum(XCompress.InterarrivalSumCubes(t-TimeWindows(i)+1 : t));
            mean_interarrival = sum_interarrival / number_packets;
            var_interarrival = (sumsquares_interarrival / number_packets) - mean_interarrival^2;
            Features.CVPacketInterarrival(t-tstart+1, i) = sqrt(var_interarrival)/mean_interarrival;
            Features.ThirdMomentPacketInterarrival(t-tstart+1, i) = (sumscubes_interarrival/number_packets) - 3*mean_interarrival*(sumsquares_interarrival/number_packets) + 2*mean_interarrival^3;
        end
    end
end

% Re-shaping because Matlab automatically transoped very short label cell arrays from 2
% by 1 to 1 by 2
Labels.HLClass = reshape(Labels.HLClass, [ max(size(Labels.HLClass)), 1]);
Labels.LLClass = reshape(Labels.LLClass, [ max(size(Labels.LLClass)), 1]);

end
