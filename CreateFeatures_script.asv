%% Import data from text file.
% Script for importing data from the following text file:
%
%    /Users/alittle2/Dropbox/JU/Scholarship/MachineLearning_Security/RealTime/CodeForDARPA/inside_5_5_new.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2017/05/03 14:11:25

%% Initialize variables.

for m = 1:100
    disp("NEW RUN..........");
end

%Define Time Windows:
TimeWindows = [1 2 4 8 16 32 60];

%long files:
%largest file directly below:
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_4_split_2_fdformat_u2r.csv'
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_1_split_6_apache2_dos.csv'
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_2_split_2_casesen_u2r.csv'

% File used for original coding:
% filename = 'inside_5_1_split_11.csv';

% Short files for testing:
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_1_split_16_ls_probe.csv'
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_1_split_7_dosnuke_dos.csv'
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\test_file.csv'
filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_5_split_0_portsweep_probe.csv'
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_1_split_13_syslogd_dos.csv'
%filename = 'C:\Users\User\Documents\GitHub\ids_svm_slidingwindow\fakedata\inside_5_1_split_0_pod_dos.csv'
%filename = 'inside_5_4_split_9_ls_probe.csv'; %too short (61 < 64 sec)
%filename = 'inside_5_1_split_15.csv'; %okay
%filename = 'inside_5_1_split_16.csv'; %too short (62 < 64 sec)

delimiter = ',';
startRow = 1;%this was originally 2, why?

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%q%q%q%q%q%q%q%q%q%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'HeaderLines' ,startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
  raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
  for col=1:length(dataArray)-1
      raw(1:length(dataArray{col}),col) = dataArray{col};
  end
  numericData = NaN(size(dataArray{1},1),size(dataArray,2)); 

%  col = 8;
%      % Converts strings in the input cell array to numbers. Replaced non-numeric
%      % strings with NaN.
%      rawData = dataArray{col};
%      for row=1:size(rawData, 1)
%          % Create a regular expression to detect and remove non-numeric prefixes and
%          % suffixes.
%          regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
%          try
%              result = regexp(rawData{row}, regexstr, 'names');
%              numbers = result.numbers;
%              
%              % Detected commas in non-thousand locations.
%              invalidThousandsSeparator = false;
%              if any(numbers==',')
%                  thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
%                  if isempty(regexp(numbers, thousandsRegExp, 'once'))
%                      numbers = NaN;
%                      invalidThousandsSeparator = true;
%                  end
%              end
%              % Convert numeric strings to numbers.
%              if ~invalidThousandsSeparator
%                  numbers = textscan(strrep(numbers, ',', ''), '%f');
%                  numericData(row, col) = numbers{1};
%                  raw{row, col} = numbers{1};
%              end
%          catch me
%          end
%      end
 
%no = cellfun(@str2num,dataArray{1, 3});
%length = cellfun(@str2num,dataArray{1, 8});

% Convert the contents of columns with dates to MATLAB datetimes using date
% format string.
try
    dates{4} = datetime(dataArray{4}, 'Format', 'HH:mm:ss.SS', 'InputFormat', 'HH:mm:ss.SS');
catch
    try
        % Handle dates surrounded by quotes
        dataArray{4} = cellfun(@(x) x(2:end-1), dataArray{4}, 'UniformOutput', false);
        dates{4} = datetime(dataArray{4}, 'Format', 'HH:mm:ss.SS', 'InputFormat', 'HH:mm:ss.SS');
    catch
        dates{4} = repmat(datetime([NaN NaN NaN]), size(dataArray{4}));
    end
end

anyBlankDates = cellfun(@isempty, dataArray{4});
anyInvalidDates = isnan(dates{4}.Hour) - anyBlankDates;
dates = dates(:,4);
% 
%  %% Split data into numeric and cell columns.
%  % rawNumericColumns = raw(:, 8);
rawCellColumns = raw(:, [1,2,5,6,7,9]);
%  
%  
%% Replace non-numeric cells with NaN
% R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),rawNumericColumns); % Find non-numeric cells
% rawNumericColumns(R) = {NaN}; % Replace non-numeric cells

% Create output variable
X = table;
X.LLClass = rawCellColumns(:, 1);
X.HLClass = rawCellColumns(:, 2);
% %X.No = no;
X.Time = dates{:, 1};
X_Time_old = X.Time;
X.Source = rawCellColumns(:, 3);
X.Destination = rawCellColumns(:, 4);
X.Protocol = rawCellColumns(:, 5);
X.Length = cellfun(@str2num,dataArray{1, 8});
X.Info = rawCellColumns(:, 6);

%% Clear temporary variables
clearvars filename delimiter startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers inval

%% Define additional packet-level features which will be used to compute features for various time windows
X.Time = 3600*hour(X.Time)+60*minute(X.Time)+second(X.Time); % Convert datetime format to time in seconds (only use for csv files!)

%% Packet Interarrival
X.PacketInterarrival = [0; diff(X.Time)]; % Time since previous packet; for first packet make this zero since there is no prior packet

% Create a new time column that is always increasing by adding 3,600 when
% the hour changes
% Note: negative(1:8) is required to include 8 different hours that may be
% included in one file
for i=1:8
    negative(i) = 0;
end
j = 1;
for i = 1:(length(X.Time) - 1)
    if(X.Time(i+1) - X.Time(i) < 0)
        negative(j) = i;
        j = j + 1;
    end
end
for j=1:8
    if negative(j) > 0
        for i = negative(j):length(X.Time)
            X.Time(i) = X.Time(i) + j*3600;
        end
    end
end

% Find indices which partition the data into one second intervals
edges = X.Time(1):1:X.Time(length(X.Time));
edges(length(edges)) = X.Time(length(X.Time)); %Round last entry up to include all times
SecondIndex = discretize(X.Time, edges);

% moved NumberOfSeconds for files that change the hour and we add 3,600 it
% needs to be calculated here
NumberOfSeconds = floor(X.Time(length(X.Time))-X.Time(1));
%% Compress Data into Second-level summary data (the summary data will be used to compute features over different time windows)
% Note: each row represents one second

XCompress = table;
XCompress.NumberOfPackets = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSum = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSumSquares = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSumCubes = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSum = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSumSquares = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSumCubes = zeros(NumberOfSeconds,1);
XCompress.HLClass = cell(NumberOfSeconds,1);
XCompress.LLClass = cell(NumberOfSeconds,1);
XCompress.CorJavaScriptCount = zeros(NumberOfSeconds,1);
XCompress.HTTPandMalformedCount = zeros(NumberOfSeconds,1);
XCompress.HTTPorFTPandExeCodeCount = zeros(NumberOfSeconds,1);
XCompress.FTPandCcodeCount = zeros(NumberOfSeconds,1);
XCompress.SYNCount = zeros(NumberOfSeconds,1);
XCompress.ECHOCount = zeros(NumberOfSeconds,1);

%counters below for verification of correctness of expected and actual flag counts
http_malformed_packet_counter = 0;
ftp_dotc_counter = 0;
httpftp_dotexe_counter = 0;
syn_flag_counter = 0;
echo_flag_counter = 0;

for i=1:NumberOfSeconds
    index = find(SecondIndex==i);%finds all elements in nonzero second tables
    
    % Record the High level class
    % Note: if there are no packets in the interval, the label is taken
    % from the previous interval
    if length(index) == 0
        XCompress.HLClass(i) = XCompress.HLClass(i-1);
        XCompress.LLClass(i) = XCompress.LLClass(i-1);
    else
        possible_labelsHL = unique(X.HLClass(index));
        possible_labelsLL = unique(X.LLClass(index));
        if length(possible_labelsHL) == 1
           XCompress.HLClass(i) = possible_labelsHL;
           XCompress.LLClass(i) = possible_labelsLL;
        else
            n = zeros(length(possible_labelsHL), 1);
            for j = 1:length(possible_labelsHL)
              n(j) = length(find(strcmp(possible_labelsHL{j}, X.HLClass(index))));
            end
            [~, itemp] = max(n);
            XCompress.HLClass(i)=possible_labelsHL(itemp);
            XCompress.LLClass(i)=possible_labelsLL(itemp);
        end
    end

    % Packet Size Info (for CV and third moment of packet size)
    XCompress.NumberOfPackets(i) = length(index);
    XCompress.PacketSizeSum(i) = sum(X.Length(index));
    XCompress.PacketSizeSumSquares(i) = sum(X.Length(index).^2);
    XCompress.PacketSizeSumCubes(i) = sum(X.Length(index).^3);
    
    % Inter-arrival info (for CV of packet inter-arrival rate)
    XCompress.InterarrivalSum(i) = sum(X.PacketInterarrival(index));
    XCompress.InterarrivalSumSquares(i) = sum(X.PacketInterarrival(index).^2);
    XCompress.InterarrivalSumCubes(i) = sum(X.PacketInterarrival(index).^3);
    
    % Record C or Javascript Count
    if length(index)>0
        expr_C = '} | { |if( | for( | main(';
        expr_Javascript = 'attr|index|all|id|value|className|document|getElement*';
        code_flag_count = 0;
        for j=index(1):index(length(index));
            [startStr1] = regexp(X.Info(j), expr_C);
            [startStr2] = regexp(X.Info(j), expr_Javascript);
            if(length(startStr1{1,1}) > 0 || length(startStr2{1,1}) > 0)
                code_flag_count = code_flag_count+1;
            end
        end
        XCompress.CorJavaScriptCount(i) = code_flag_count;
    end
    
    % Record HTTP and Malformed Count
    %returns the number of Malformed HTTP packets per second
    if length(index)>0
        code_flag_count = 0;
        
        %malformed_string_indeces = strfind(X.Info(index),'Malformed');
       malformed_string_indeces = regexp(X.Info(index),'Malformed', 'match', 'ignorecase');%returns index of syn string if relevant
       http_protocol = regexp(X.Protocol(index),'HTTP', 'match', 'ignorecase');
       for n = 1:length(malformed_string_indeces)
           %disp(syn_string_indeces{n});
           if ~isempty(malformed_string_indeces{n})%if it is empty, strfind found no match, and thus returned no index
               if ~isempty(http_protocol{n})%if it is empty, the protocol was not http
                   
                   http_malformed_packet_counter = http_malformed_packet_counter + 1;
              % fprintf('\n\n\n\nthere is a malformed packet at line %i\n\n\n\n', index);
                   XCompress.HTTPandMalformedCount(i) = XCompress.HTTPandMalformedCount(i) + 1;
               end
           end
       end
       
       %old code
       
       %for j=index(1):index(length(index));
        %    [startStr6] = regexp(X.Protocol(j), 'HTTP');
        %    [startStr7] = regexp(X.Info(j), 'Malformed Packet');
         %   if(length(startStr6{1,1}) > 0 && length(startStr7{1,1}) > 0)
         %       code_flag_count = code_flag_count+1;
         %   end
        %end
       % XCompress.HTTPandMalformedCount(i) = code_flag_count;
    end
    
    %Record *.exe in payload and HTTP or FTP in protocol
    if length(index)>0
       dotexe_regex = '\.*((\.exe[^a-zA-Z+]|\.exe$))';%finds .exe strings with 0 or more characters after, and ignores english letters after .c
       dotexe_string_indeces = regexp(X.Info(index),dotexe_regex, 'match');
       httpftp_protocol = regexp(X.Protocol(index),'HTTP|FTP', 'match', 'ignorecase');
       
       for n = 1:length(dotexe_string_indeces)
           %disp(syn_string_indeces{n});
           if ~isempty(dotexe_string_indeces{n})%if it is empty, regexp found no match, and thus returned no index
               if ~isempty(httpftp_protocol{n})
                   %fprintf('\n\n\n.exe match here at index %i\n\n\n', index);
                   httpftp_dotexe_counter = httpftp_dotexe_counter + 1;
                   
                   XCompress.HTTPorFTPandExeCodeCount(i) = XCompress.HTTPorFTPandExeCodeCount(i) + 1;
               end
           end
       end
    end
    
    % Record FTP in protocol and "*.c" in content flag
    if length(index)>0
       %dotc_regex = '.c';
       dotc_regex = '\.*((\.c[^a-zA-Z+]|\.c$))';%finds .c strings with 0 or more characters after, and ignores english letters after .c
       dotc_string_indeces = regexp(X.Info(index),dotc_regex, 'match');
       ftp_protocol = regexp(X.Protocol(index),'FTP', 'match', 'ignorecase');
      
       
       for n = 1:length(dotc_string_indeces)
           
           %disp(syn_string_indeces{n});
           if ~isempty(dotc_string_indeces{n})%if it is empty, regexp found no match, and thus returned no index
               if ~isempty(ftp_protocol{n})
                   %fprintf('\n\n\n.c match here at index %i\n\n\n', index);
                   ftp_dotc_counter = ftp_dotc_counter + 1;
                   
                   %records ftp and .c counts per second
                   XCompress.FTPandCcodeCount(i) = XCompress.FTPandCcodeCount(i) + 1;
               end
           end
       end
       % code_flag_count = 0;
       % for j=index(1):index(length(index));
       %     [startStr6] = regexp(X.Protocol(j), 'FTP');
        %    [startStr7] = regexp(X.Info(j), '.c');
       %     if(length(startStr6{1,1}) > 0 && length(startStr7{1,1}) > 0)
      %          code_flag_count = code_flag_count+1;
       %     end
      %  end
       % XCompress.FTPandCcodeCount(i) = code_flag_count;
    end
    
    % Record SYN flag counts
    if length(index)>0
   % if index>0
        
       syn_string = '[SYN]';
       
       syn_string_indeces = strfind(X.Info(index),syn_string);%returns index of syn string if relevant
       syn_protocol = strfind(X.Protocol(index),'TCP');%returns value if it is a TCP protocol
       %fprintf('the value for index &i is %i. ', index, syn_string_indeces(1));
      % fprintf('\ndisplay syn string below for index %i ', index);
       
       for n = 1:length(syn_string_indeces)
           %disp(syn_string_indeces{n});
           if ~isempty(syn_string_indeces{n})%if it is empty, strfind found no match, and thus returned no index
               if ~isempty(syn_protocol{n})%if this is empty, it is not TCP protocol
                   syn_flag_counter = syn_flag_counter + 1;
                   %Line below helps to manually see which packets contain SYN flags and how many individual seconds contain a SYN flag
                   %fprintf('\n\nSecond %i contains a SYN flag!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n',i);
              
                   XCompress.SYNCount(i) = 1;%set to one because a single occurence flags the entire second as a positive
               end
           end
       end
       
       %OLD CODE:
       
       %fprintf('\nyoyoyo the X.Info(index) of index %i: ',index);% disp(X.Info(index));
       %XCompress.SYNCount(i) = length(strcmp(syn_string,regexp(X.Info(index),syn_string,'match')));
      % XCompress.SYNCount(i) = length(find(strcmp('SYN', X.Protocol(index)))); 
       %XCompress.ECHOCount(i) = length(find(strcmp('ECHO', X.Protocol(index)))); 
      % fprintf("the index is %i\n", index);
    end
    
    %Record ECHO counts
    if length(index) > 0
       echo_string = 'Echo';
       
       echo_string_indeces = strfind(X.Info(index),echo_string);%returns the indeces of the matching string if relevant
       echo_string_protocol = strfind(X.Protocol(index),'ICMP');%Determines if the echo type is ICMP
       %fprintf('the value for index &i is %i. ', index, syn_string_indeces(1));
       fprintf('\ndisplay echo string below for index %i ', index);
       
       for n = 1:length(echo_string_indeces)
           %disp(echo_string_indeces{n});
           if ~isempty(echo_string_indeces{n})%if it is empty, strfind found no match, and thus returned no index
               if ~isempty(echo_string_protocol{n})%only counts if it is an icmp type
                   echo_flag_counter = echo_flag_counter + 1;
                   
                   %Line below helps to manually see which packets contain SYN flags and how many individual seconds contain a SYN flag
                   %fprintf('\n\nSecond %i contains an ECHO flag!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n',i);
              
                   XCompress.ECHOCount(i) = 1;%set to one because a single occurence flags the entire second as a positive
               end
           end
       end
    end
    
end

fprintf('\n\nthe number of HTTP Malformed packets is %i', http_malformed_packet_counter);
fprintf('\nthe number of HTTP or FTP .exe packets is %i', httpftp_dotexe_counter);
fprintf('\nthe number of FTP .c packets is %i', ftp_dotc_counter);
fprintf('\nthe number of syn flags is %i', syn_flag_counter);
fprintf('\nthe number of echo flags is %i', echo_flag_counter);

%% Define Features In Various Time Windows

T = length(TimeWindows);
% First time that we can compute features for ALL windows
tstart = max(TimeWindows);
tend = length(XCompress.NumberOfPackets);
ttotal = tend - tstart;

Features = struct;
Labels = struct;

Features.CVPacketSize = zeros(ttotal,T);
Features.ThirdMomentPacketSize = zeros(ttotal,T);
Features.CVPacketInterarrival = zeros(ttotal,T);
Features.ThirdMomentPacketInterarrival = zeros(ttotal,T);
Features.HTTPorFTPandExeCodeCount = zeros(ttotal,T);
Features.CorJavaScriptCount = zeros(ttotal,T);
Features.HTTPandMalformedCount = zeros(ttotal,T);
Features.FTPandCcodeCount = zeros(ttotal,T);
Features.SYNCount = zeros(ttotal,T);
Features.ECHOCount = zeros(ttotal,T);

Labels.HLClass = cell(ttotal,1);
Labels.LLClass = cell(ttotal,1);

for t=tstart:tend %Loop over times
    for i = 1:T %Loop over windows
        Labels.HLClass(t-tstart+1) = XCompress.HLClass(t);
        Labels.LLClass(t-tstart+1) = XCompress.LLClass(t);
        Features.SYNCount(t-tstart+1, i) = sum(XCompress.SYNCount(t-TimeWindows(i)+1 : t));
        Features= sum(XCompress.HTTPorFTPandExeCodeCount(t-TimeWindows(i)+1 : t));
        Features.CorJavaScriptCount(t-tstart+1, i) = sum(XCompress.CorJavaScriptCount(t-TimeWindows(i)+1 : t));
        Features.HTTPandMalformedCount(t-tstart+1, i) = sum(XCompress.HTTPandMalformedCount(t-TimeWindows(i)+1 : t));
        Features.FTPandCcodeCount(t-tstart+1, i) = sum(XCompress.FTPandCcodeCount(t-TimeWindows(i)+1 : t));
        Features.SYNCount(t-tstart+1, i) = sum(XCompress.SYNCount(t-TimeWindows(i)+1 : t));
        Features.ECHOCount(t-tstart+1, i) = sum(XCompress.ECHOCount(t-TimeWindows(i)+1 : t));
        % Construct features from sotred information: 
        number_packets = sum(XCompress.NumberOfPackets(t-TimeWindows(i)+1 : t));
        if number_packets > 0
            % Packet Size
            sum_packetsize = sum(XCompress.PacketSizeSum(t-TimeWindows(i)+1 : t));
            sumsquares_packetsize = sum(XCompress.PacketSizeSumSquares(t-TimeWindows(i)+1 : t));
            sumscubes_packetsize = sum(XCompress.PacketSizeSumCubes(t-TimeWindows(i)+1 : t));
            mean_packetsize = sum_packetsize / number_packets;
            var_packetsize = (sumsquares_packetsize / number_packets) - mean_packetsize^2;
            Features.CVPacketSize(t-tstart+1, i) = sqrt(var_packetsize)/mean_packetsize;
            Features.ThirdMomentPacketSize(t-tstart+1, i) = (sumscubes_packetsize/number_packets) - 3*mean_packetsize*(sumsquares_packetsize/number_packets) + 2*mean_packetsize^3;
            % Packet Interarrival
            sum_interarrival = sum(XCompress.InterarrivalSum(t-TimeWindows(i)+1 : t));
            sumsquares_interarrival = sum(XCompress.InterarrivalSumSquares(t-TimeWindows(i)+1 : t));
            sumscubes_interarrival = sum(XCompress.InterarrivalSumCubes(t-TimeWindows(i)+1 : t));
            mean_interarrival = sum_interarrival / number_packets;
            var_interarrival = (sumsquares_interarrival / number_packets) - mean_interarrival^2;
            Features.CVPacketInterarrival(t-tstart+1, i) = sqrt(var_interarrival)/mean_interarrival;
            Features.ThirdMomentPacketInterarrival(t-tstart+1, i) = (sumscubes_interarrival/number_packets) - 3*mean_interarrival*(sumsquares_interarrival/number_packets) + 2*mean_interarrival^3;
        end
    end
end


