%Same as CreateFeatures_function.m, but scales features using zscore so that all
%features have a standard deviation of 1

function [Features, Labels] = CreateScaledFeatures_function( filename, TimeWindows );

%% Import data from text file.
% Script for importing data from the following text file:
%
%    /Users/alittle2/Dropbox/JU/Scholarship/MachineLearning_Security/RealTime/CodeForDARPA/inside_5_5_new.csv
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2017/05/03 14:11:25

%% Initialize variables.

for m = 1:50
    fprintf("\nNEW RUN.......... on %s",filename);
end

delimiter = ',';
startRow = 1;

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%q%q%q%q%q%q%q%q%q%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'HeaderLines' ,startRow-1, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
  raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
  for col=1:length(dataArray)-1
      raw(1:length(dataArray{col}),col) = dataArray{col};
  end
  numericData = NaN(size(dataArray{1},1),size(dataArray,2)); 


% Convert the contents of columns with dates to MATLAB datetimes using date
% format string.
try
    dates{4} = datetime(dataArray{4}, 'Format', 'HH:mm:ss.SS', 'InputFormat', 'HH:mm:ss.SS');
catch
    try
        % Handle dates surrounded by quotes
        dataArray{4} = cellfun(@(x) x(2:end-1), dataArray{4}, 'UniformOutput', false);
        dates{4} = datetime(dataArray{4}, 'Format', 'HH:mm:ss.SS', 'InputFormat', 'HH:mm:ss.SS');
    catch
        dates{4} = repmat(datetime([NaN NaN NaN]), size(dataArray{4}));
    end
end

anyBlankDates = cellfun(@isempty, dataArray{4});
anyInvalidDates = isnan(dates{4}.Hour) - anyBlankDates;
dates = dates(:,4);
% 
%  %% Split data into numeric and cell columns.
%  % rawNumericColumns = raw(:, 8);
rawCellColumns = raw(:, [1,2,5,6,7,9]);
%  
%  
%% Replace non-numeric cells with NaN
% R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),rawNumericColumns); % Find non-numeric cells
% rawNumericColumns(R) = {NaN}; % Replace non-numeric cells

% Create output variable
X = table;
X.LLClass = rawCellColumns(:, 1);
%these all have a space for the first char. remove with line below
X.HLClass = strip(rawCellColumns(:, 2), ' ');
X.Time = dates{:, 1};
X_Time_old = X.Time;
X.Source = rawCellColumns(:, 3);
X.Destination = rawCellColumns(:, 4);
X.Protocol = rawCellColumns(:, 5);
X.Length = cellfun(@str2num,dataArray{1, 8});
X.Info = rawCellColumns(:, 6);

%% Clear temporary variables
clearvars filename delimiter startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers inval

%% Define additional packet-level features which will be used to compute features for various time windows
X.Time = 3600*hour(X.Time)+60*minute(X.Time)+second(X.Time); % Convert datetime format to time in seconds (only use for csv files!)

%% Packet Interarrival
X.PacketInterarrival = [0; diff(X.Time)]; % Time since previous packet; for first packet make this zero since there is no prior packet

% Create a new time column that is always increasing by adding 3,600 when
% the hour changes
% Note: negative(1:8) is required to include 8 different hours that may be
% included in one file
for i=1:8
    negative(i) = 0;
end
j = 1;
for i = 1:(length(X.Time) - 1)
    if(X.Time(i+1) - X.Time(i) < 0)
        negative(j) = i;
        j = j + 1;
    end
end
for j=1:8
    if negative(j) > 0
        for i = negative(j):length(X.Time)
            X.Time(i) = X.Time(i) + j*3600;
        end
    end
end

% Find indices which partition the data into one second intervals
edges = X.Time(1):1:X.Time(length(X.Time));
edges(length(edges)) = X.Time(length(X.Time)); %Round last entry up to include all times
SecondIndex = discretize(X.Time, edges);

% moved NumberOfSeconds for files that change the hour and we add 3,600 it
% needs to be calculated here
NumberOfSeconds = floor(X.Time(length(X.Time))-X.Time(1));
%% Compress Data into Second-level summary data (the summary data will be used to compute features over different time windows)
% Note: each row represents one second

XCompress = table;
XCompress.NumberOfPackets = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSum = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSumSquares = zeros(NumberOfSeconds,1);
XCompress.PacketSizeSumCubes = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSum = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSumSquares = zeros(NumberOfSeconds,1);
XCompress.InterarrivalSumCubes = zeros(NumberOfSeconds,1);
XCompress.HLClass = cell(NumberOfSeconds,1);
XCompress.LLClass = cell(NumberOfSeconds,1);
XCompress.CorJavaScriptCount = zeros(NumberOfSeconds,1);
XCompress.HTTPandMalformedCount = zeros(NumberOfSeconds,1);
XCompress.HTTPorFTPandExeCodeCount = zeros(NumberOfSeconds,1);
XCompress.FTPandCcodeCount = zeros(NumberOfSeconds,1);
XCompress.SYNCount = zeros(NumberOfSeconds,1);
XCompress.ECHOCount = zeros(NumberOfSeconds,1);

%counters below for verification of correctness of expected and actual flag counts
http_malformed_packet_counter = 0;
ftp_dotc_counter = 0;
httpftp_dotexe_counter = 0;
syn_flag_counter = 0;
echo_flag_counter = 0;

for i=1:NumberOfSeconds
    index = find(SecondIndex==i);%finds all elements in nonzero second tables
    
    % Record the High level class
    % Note: if there are no packets in the interval, the label is taken
    % from the previous interval
    if length(index) == 0
        XCompress.HLClass(i) = XCompress.HLClass(i-1);
        XCompress.LLClass(i) = XCompress.LLClass(i-1);
    else
        possible_labelsHL = unique(X.HLClass(index));
        possible_labelsLL = unique(X.LLClass(index));
        if length(possible_labelsHL) == 1
           XCompress.HLClass(i) = possible_labelsHL;
           XCompress.LLClass(i) = possible_labelsLL;
        else
            n = zeros(length(possible_labelsHL), 1);
            for j = 1:length(possible_labelsHL)
              n(j) = length(find(strcmp(possible_labelsHL{j}, X.HLClass(index))));
            end
            [~, itemp] = max(n);
            XCompress.HLClass(i)=possible_labelsHL(itemp);
            XCompress.LLClass(i)=possible_labelsLL(itemp);
        end
    end

    % Packet Size Info (for CV and third moment of packet size)
    XCompress.NumberOfPackets(i) = length(index);
    XCompress.PacketSizeSum(i) = sum(X.Length(index));
    XCompress.PacketSizeSumSquares(i) = sum(X.Length(index).^2);
    XCompress.PacketSizeSumCubes(i) = sum(X.Length(index).^3);
    
    % Inter-arrival info (for CV of packet inter-arrival rate)
    XCompress.InterarrivalSum(i) = sum(X.PacketInterarrival(index));
    XCompress.InterarrivalSumSquares(i) = sum(X.PacketInterarrival(index).^2);
    XCompress.InterarrivalSumCubes(i) = sum(X.PacketInterarrival(index).^3);
    
    % Record C or Javascript Count
    if length(index)>0
        expr_C = '} | { |if( | for( | main(';
        expr_Javascript = 'attr|index|all|id|value|className|document|getElement*';
        code_flag_count = 0;
        for j=index(1):index(length(index));
            [startStr1] = regexp(X.Info(j), expr_C);
            [startStr2] = regexp(X.Info(j), expr_Javascript);
            if(length(startStr1{1,1}) > 0 || length(startStr2{1,1}) > 0)
                code_flag_count = code_flag_count+1;
            end
        end
        XCompress.CorJavaScriptCount(i) = code_flag_count;
    end
    
    % Record HTTP and Malformed Count
    %returns the number of Malformed HTTP packets per second
    if length(index)>0
        code_flag_count = 0;
        
        %malformed_string_indeces = strfind(X.Info(index),'Malformed');
       malformed_string_indeces = regexp(X.Info(index),'Malformed', 'match', 'ignorecase');%returns index of syn string if relevant
       http_protocol = regexp(X.Protocol(index),'HTTP', 'match', 'ignorecase');
       for n = 1:length(malformed_string_indeces)
           
           if ~isempty(malformed_string_indeces{n})%if it is empty, strfind found no match, and thus returned no index
               if ~isempty(http_protocol{n})%if it is empty, the protocol was not http
                   
                   http_malformed_packet_counter = http_malformed_packet_counter + 1;
                   XCompress.HTTPandMalformedCount(i) = XCompress.HTTPandMalformedCount(i) + 1;
               end
           end
       end
    end
    
    %Record *.exe in payload and HTTP or FTP in protocol
    if length(index)>0
       dotexe_regex = '\.*((\.exe[^a-zA-Z+]|\.exe$))';%finds .exe strings with 0 or more characters after, and ignores english letters after .c
       dotexe_string_indeces = regexp(X.Info(index),dotexe_regex, 'match');
       httpftp_protocol = regexp(X.Protocol(index),'HTTP|FTP', 'match', 'ignorecase');
       
       for n = 1:length(dotexe_string_indeces)
           if ~isempty(dotexe_string_indeces{n})%if it is empty, regexp found no match, and thus returned no index
               if ~isempty(httpftp_protocol{n})
                   
                   httpftp_dotexe_counter = httpftp_dotexe_counter + 1;
                   
                   XCompress.HTTPorFTPandExeCodeCount(i) = XCompress.HTTPorFTPandExeCodeCount(i) + 1;
               end
           end
       end
    end
    
    % Record FTP in protocol and "*.c" in content flag
    if length(index)>0
        
       dotc_regex = '\.*((\.c[^a-zA-Z+]|\.c$))';%finds .c strings with 0 or more characters after, and ignores english letters after .c
       dotc_string_indeces = regexp(X.Info(index),dotc_regex, 'match');
       ftp_protocol = regexp(X.Protocol(index),'FTP', 'match', 'ignorecase');
      
       
       for n = 1:length(dotc_string_indeces)
           
           if ~isempty(dotc_string_indeces{n})%if it is empty, regexp found no match, and thus returned no index
               if ~isempty(ftp_protocol{n})
                   ftp_dotc_counter = ftp_dotc_counter + 1;
                   
                   %records ftp and .c counts per second
                   XCompress.FTPandCcodeCount(i) = XCompress.FTPandCcodeCount(i) + 1;
               end
           end
       end
    end
    
    % Record SYN flag counts
    if length(index)>0
   % if index>0
        
       syn_string = '[SYN]';
       
       syn_string_indeces = strfind(X.Info(index),syn_string);%returns index of syn string if relevant
       syn_protocol = strfind(X.Protocol(index),'TCP');%returns value if it is a TCP protocol
       
       for n = 1:length(syn_string_indeces)
           if ~isempty(syn_string_indeces{n})%if it is empty, strfind found no match, and thus returned no index
               if ~isempty(syn_protocol{n})%if this is empty, it is not TCP protocol
                   syn_flag_counter = syn_flag_counter + 1;
             
                   XCompress.SYNCount(i) = 1;%set to one because a single occurence flags the entire second as a positive
               end
           end
       end
       
    end
    
    %Record ECHO counts
    if length(index) > 0
       echo_string = 'Echo';
       
       echo_string_indeces = strfind(X.Info(index),echo_string);%returns the indeces of the matching string if relevant
       echo_string_protocol = strfind(X.Protocol(index),'ICMP');%Determines if the echo type is ICMP
       
       for n = 1:length(echo_string_indeces)
           if ~isempty(echo_string_indeces{n})%if it is empty, strfind found no match, and thus returned no index
               if ~isempty(echo_string_protocol{n})%only counts if it is an icmp type
                   echo_flag_counter = echo_flag_counter + 1;
                         
                   XCompress.ECHOCount(i) = 1;%set to one because a single occurence flags the entire second as a positive
               end
           end
       end
    end
    
end

fprintf('\n\nthe number of HTTP Malformed packets is %i', http_malformed_packet_counter);
fprintf('\nthe number of HTTP or FTP .exe packets is %i', httpftp_dotexe_counter);
fprintf('\nthe number of FTP .c packets is %i', ftp_dotc_counter);
fprintf('\nthe number of syn flags is %i', syn_flag_counter);
fprintf('\nthe number of echo flags is %i', echo_flag_counter);

%% Define Features In Various Time Windows

num_of_time_windows = length(TimeWindows);

start_time = 1;
end_time = length(XCompress.NumberOfPackets);
total_time = end_time - start_time;

Features = struct;
Labels = struct;

Features.CVPacketSize = zeros(total_time,num_of_time_windows);
Features.ThirdMomentPacketSize = zeros(total_time,num_of_time_windows);
Features.CVPacketInterarrival = zeros(total_time,num_of_time_windows);
Features.ThirdMomentPacketInterarrival = zeros(total_time,num_of_time_windows);
Features.HTTPorFTPandExeCodeCount = zeros(total_time,num_of_time_windows);
Features.CorJavaScriptCount = zeros(total_time,num_of_time_windows);
Features.HTTPandMalformedCount = zeros(total_time,num_of_time_windows);
Features.FTPandCcodeCount = zeros(total_time,num_of_time_windows);
Features.SYNCount = zeros(end_time,num_of_time_windows);
Features.ECHOCount = zeros(total_time,num_of_time_windows);

Labels.HLClass = cell(end_time,1);
Labels.LLClass = cell(total_time,1);

for sec=start_time:end_time %Loop over times
    for i = 1:num_of_time_windows %Loop over windows
        
        Labels.HLClass(sec-start_time+1) = XCompress.HLClass(sec);
        Labels.LLClass(sec-start_time+1) = XCompress.LLClass(sec);
        
        %time window is too large to hold first i seconds
        %set all irrelevant sliding windows to NaN
        if(TimeWindows(i) > sec)
            Features.SYNCount(sec-start_time+1, i) = NaN;
            Features.HTTPorFTPandExeCodeCount(sec-start_time+1,i) = NaN;
            Features.CorJavaScriptCount(sec-start_time+1, i) = NaN;
            Features.HTTPandMalformedCount(sec-start_time+1, i) = NaN;
            Features.FTPandCcodeCount(sec-start_time+1, i) = NaN;
            Features.SYNCount(sec-start_time+1, i) = NaN;
            Features.ECHOCount(sec-start_time+1, i) = NaN;
            Features.CVPacketSize(sec-start_time+1, i) = NaN;
            Features.ThirdMomentPacketSize(sec-start_time+1, i) = NaN;
            Features.CVPacketInterarrival(sec-start_time+1, i) = NaN;
            Features.ThirdMomentPacketInterarrival(sec-start_time+1, i) = NaN;
            
        %current time window is >= the current seconds passed
        else

            Features.SYNCount(sec-start_time+1, i) = sum(XCompress.SYNCount(sec-TimeWindows(i)+1 : sec));
            Features.HTTPorFTPandExeCodeCount(sec-start_time+1,i) = sum(XCompress.HTTPorFTPandExeCodeCount(sec-TimeWindows(i)+1 : sec));
            Features.CorJavaScriptCount(sec-start_time+1, i) = sum(XCompress.CorJavaScriptCount(sec-TimeWindows(i)+1 : sec));
            Features.HTTPandMalformedCount(sec-start_time+1, i) = sum(XCompress.HTTPandMalformedCount(sec-TimeWindows(i)+1 : sec));
            Features.FTPandCcodeCount(sec-start_time+1, i) = sum(XCompress.FTPandCcodeCount(sec-TimeWindows(i)+1 : sec));
            Features.SYNCount(sec-start_time+1, i) = sum(XCompress.SYNCount(sec-TimeWindows(i)+1 : sec));
            Features.ECHOCount(sec-start_time+1, i) = sum(XCompress.ECHOCount(sec-TimeWindows(i)+1 : sec));
            
            % Construct continuous features from stored information: 
            number_packets = sum(XCompress.NumberOfPackets(sec-TimeWindows(i)+1 : sec));
            if number_packets > 0
                % Packet Size
                sum_packetsize = sum(XCompress.PacketSizeSum(sec-TimeWindows(i)+1 : sec));
                sumsquares_packetsize = sum(XCompress.PacketSizeSumSquares(sec-TimeWindows(i)+1 : sec));
                sumscubes_packetsize = sum(XCompress.PacketSizeSumCubes(sec-TimeWindows(i)+1 : sec));
                mean_packetsize = sum_packetsize / number_packets;
                var_packetsize = (sumsquares_packetsize / number_packets) - mean_packetsize^2;
                
                Features.CVPacketSize(sec-start_time+1, i) = sqrt(var_packetsize)/mean_packetsize;
                Features.ThirdMomentPacketSize(sec-start_time+1, i) = (sumscubes_packetsize/number_packets) - 3*mean_packetsize*(sumsquares_packetsize/number_packets) + 2*mean_packetsize^3;
                
                % Packet Interarrival
                sum_interarrival = sum(XCompress.InterarrivalSum(sec-TimeWindows(i)+1 : sec));
                sumsquares_interarrival = sum(XCompress.InterarrivalSumSquares(sec-TimeWindows(i)+1 : sec));
                sumscubes_interarrival = sum(XCompress.InterarrivalSumCubes(sec-TimeWindows(i)+1 : sec));
                mean_interarrival = sum_interarrival / number_packets;
                var_interarrival = (sumsquares_interarrival / number_packets) - mean_interarrival^2;
                
                Features.CVPacketInterarrival(sec-start_time+1, i) = sqrt(var_interarrival)/mean_interarrival;
                Features.ThirdMomentPacketInterarrival(sec-start_time+1, i) = (sumscubes_interarrival/number_packets) - 3*mean_interarrival*(sumsquares_interarrival/number_packets) + 2*mean_interarrival^3;
            end
        end
    end
end

% Re-shaping because Matlab automatically transposed very short label cell arrays from 2
% by 1 to 1 by 2
Labels.HLClass = reshape(Labels.HLClass, [ max(size(Labels.HLClass)), 1]);
Labels.LLClass = reshape(Labels.LLClass, [ max(size(Labels.LLClass)), 1]);

